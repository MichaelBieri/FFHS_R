Aufgabe 1 a):
```{r}
library(dplyr)
#Character vectors will not be transformed
ausfaelle <- read.csv("ausfaelle.csv", header = TRUE, stringsAsFactors = FALSE)

# Löschen der ersten Spalte
ausfaelle <- ausfaelle[ , -1]

# Konvertieren der Spalten in numerische Werte ohne doppelte Werte
ausfaelle_df <- ausfaelle %>% mutate(across(everything(), as.numeric))

# Summieren der Ausfälle pro Jahr pro Monat und in eine Liste speichern
row_sums <- ausfaelle_df %>%
  rowwise() %>%
  mutate(Total_Ausfaelle = sum(c_across(everything()))) %>%
  pull(Total_Ausfaelle)

# Jede Zeilensumme in eine eigene Variable in einer Liste speichern
Ausfaelle_pro_Jahr <- list()
for (i in seq_along(row_sums)) {
  Ausfaelle_pro_Jahr[[paste0("Ausfaelle_pro_Jahr", i)]] <- row_sums[i]
}
print(Ausfaelle_pro_Jahr)

# Ausgabe erste Zeile und die anderen
Summe_jahr_1 <- Ausfaelle_pro_Jahr[["Ausfaelle_pro_Jahr1"]]
print(Summe_jahr_1)
```
Aufgabe 1 b):
Theorie:
"ppois" kumulatie Verteilungsfunktion, berechnet die Wahrscheinlichkeit, dass die Anzahl der Ereignisse (k) kleiner oder gleich einem bestimmten Wert ist.
"dpois" Wahrschenlichkeitsdichtefunktion, dpois berechnet die Wahrscheinlichkeit dass eine bestimmte Anzahl von Ereignissen(k) bei einer gegebenen durchschnittlichen Rate in einem festen Intervall auftritt. Berechnet der Wahrscheinlichkeit eines genauen Werts.
```{r}

library(dplyr)

ausfaelle <- read.csv("ausfaelle.csv", header = TRUE, stringsAsFactors = FALSE)

ausfaelle <- ausfaelle[ , -1]

ausfaelle <- ausfaelle %>% mutate(across(everything(), as.numeric))

# Summieren der Ausfälle pro Jahr
ausfaelle <- ausfaelle %>%
  rowwise() %>%
  mutate(Total_Ausfaelle = sum(c_across(everything())))

# Extrahieren der Totalausfälle pro Jahr
total_ausfaelle_pro_jahr <- ausfaelle$Total_Ausfaelle

# Berechnen des Mittelwerts der Ausfälle pro Jahr
lambda <- mean(total_ausfaelle_pro_jahr)

# Berechnen der Wahrscheinlichkeit fuer 15 und 20 Ausfälle
prob <- ppois(20, lambda) - ppois(14, lambda)

# Ausgabe der Wahrscheinlichkeit
print(paste("Die Wahrscheinlichkeit dass sich pro Jahr zwischen 15 und 20 Ausfälle ereignen ist:", prob))
```
Aufgabe 1 c):
Der Kehrwert der Wahrscheinlichkeit ist da, um die durchschnittliche Anzahl von Versuchen oder Zeitrauemen zwischen seltenen Ereignissen zu bestimmen.
```{r}

data <- read.csv("ausfaelle.csv", header = TRUE, sep = ",")

# Struktur
str(data)

# Erste Spalte (Jahr) ignorieren und sicherstellen, dass alle Spalten numerisch sind
data <- data[,-1]
data <- data.frame(lapply(data, as.numeric))

# Gesamtanzahl der Ausfälle pro Jahr berechnen
data$Total_Ausfaelle <- rowSums(data) 

# Durchschnittliche Anzahl von Ausfällen pro Jahr Rate-Ausfall pro Jahr (λ)
lambda <- mean(data$Total_Ausfaelle)
print(paste("Durchschnittliche Anzahl von Ausfällen pro Jahr (λ):", lambda))

# Berechnung der Wahrscheinlichkeit dass in einem Jahr mindestens 25 Ausfälle auftreten
prob_min_25_failures <- 1 - ppois(24, lambda)
print(paste("Die Wahrscheinlichkeit dass in einem Jahr mindestens 25 Ausfälle auftreten:", round(prob_min_25_failures, 2)))

# Mittlere Anzahl Jahre zwischen zwei Jahren mit mindestens 25 Ausfällen
mean_years_between_25_failures <- 1 / prob_min_25_failures
print(paste("Die mittlere Anzahl Jahre zwischen zwei Jahren mit mindestens 25 Ausfällen ist:", round(mean_years_between_25_failures, 2)))
```
Aufgabe 2 a):

Metrisch skalierte Variablen.
Diskrete metrische Variablen: Diese Variablen nehmen nur endliche oder abzählbar unendliche Werte an. Beispiele sind die Anzahl von Personen in einem Raum oder die Anzahl von Autos, die eine Ampel in einer Stunde passieren.
Stetige metrische Variablen: Diese Variablen können jeden Wert innerhalb eines Intervalls annehmen. Beispiele sind Körpergröße, Temperatur oder Zeit. Alter, Gewicht.

Einfaches Histogramm = Zeigt Haeufigkeit in unterschiedlichen klassen und intervallen
Histogramm mit Dichtekurve = Fuer eine glattere Darstellung der Verteilung
Histogramm mit ggplot2 = 
```{r}
library(dplyr)
library(ggplot2)

data <- read.csv("Jugend_und_Sport_Anzahl_Kurse_Teilnehmende_und_Leitende_nach_Sportart_und_Jahr_(seit 2005).csv", header = TRUE, sep = ";", stringsAsFactors = FALSE)

# Überprüfen ob NA-Werte
sum(is.na(data))

# Falls es NA-Werte gibt können Sie sie entfernen
data <- na.omit(data)

# Anzahl Personen pro Jahr zusammenfuegen
Teilnehmer_pro_jahr <- data %>%
  group_by(jahr) %>%
  summarise(summe = sum(anzahl))

# Ausgabe der zusammengefuegten Ergebnisse
print(Teilnehmer_pro_jahr)

# Teilnehmer nach Anzahl plotten
x <- data$jahr
y <- data$anzahl

plot(x,y, col="blue", ylab="Anzahl Teilnehmer", xlab="Jahre", 
          main="Anzahl Teilenehmer pro Jahr",pch=13) 

# Histogramm erstellen
ggplot(Teilnehmer_pro_jahr, aes(x = jahr, y = summe)) +
  geom_histogram(stat = "identity", fill = "lightblue", color = "black") +
  labs(title = "Histogramm Anzahl Teilnehmer pro Jahr", x = "Jahre", y = "Anzahl Teilnehmer") +
  theme_minimal()
```
Daten sind ungeeignet. Normalverteilung.
```{r}
library(readxl)
library(ggplot2)

load("zeitdauerGesamtheit.RData", values <- new.env())
ls.str(values)
```
```{r}
load("zeitdauerGesamtheit.RData")

library(ggplot2)

load("zeitdauerGesamtheit.RData", values <- new.env())

# Einfacher plot der Values zeitdauer (bringt nichts, lange rechenzeit)
#plot(zeitdauerGesamtheit)

# Histogramm erstellen
ggplot(data.frame(zeitdauer = zeitdauerGesamtheit), aes(x = zeitdauer)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogramm der Zeitdauer", x = "Zeitdauer", y = "Häufigkeit")
```




Aufgabe 2 b): Eine Exponentialverteilung.
Aufgabe 2 c): Dichtefunktion
```{r}
load("zeitdauerGesamtheit.RData")

library(ggplot2)

load("zeitdauerGesamtheit.RData", values <- new.env())

ggplot(data.frame(zeitdauer = zeitdauerGesamtheit), aes(x = zeitdauer)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogramm der Zeitdauer", x = "Zeitdauer", y = "Haeufigkeit")

# Histogram mit Dichtefunktion
ggplot(data.frame(zeitdauer = zeitdauerGesamtheit), aes(x = zeitdauer)) +
  geom_histogram(aes(y = after_stat(density)), binwidth = 1, fill = "lightblue", color = "black") +
  geom_density(color = "red") +
  labs(title = "Histogramm der Zeitdauer mit Wahrscheinlichkeitsdichtefunktion", x = "Zeitdauer", y = "Hauefigkeit")
```
Aufgabe 2 d): Quantile-Quantile-Plot
```{r}
library(ggplot2)
library(stats)

load("zeitdauerGesamtheit.RData", values <- new.env())

ggplot(data.frame(zeitdauer = zeitdauerGesamtheit), aes(x = zeitdauer)) + geom_qq(distribution = qexp, dparams = list(rate = 1/mean(zeitdauer)), color = "blue") + geom_abline(intercept = 0, slope = 1, color = "red") + labs(title = "Quantil-Quantil-Plot (Q-Q-Plot) der Zeitdauer", x = "Theoretische Quantile (Exponentialverteilung)", y = "Empirische Quantile") +
  theme_minimal()
```
Aufgabe 3 a)
```{r}
library(readxl)
library(ggplot2)

# .RData-Datei
load("zeitdauerGesamtheit.RData", envir = values <- new.env())


zeitdauer <- values$zeitdauerGesamtheit

# Konvertieren in numerische Werte und NA-Werte entfernen
zeitdauer <- na.omit(zeitdauer)
zeitdauer <- as.numeric(unlist(zeitdauer))

# Funktion sample() zur Entnahme von 100 Stichproben mit unterschiedlichem Umfang aber auswahl
entnehme_proben <- function(data, num_proben = 100, sample_sizes = c(10, 50, 100, 500, 1000)) {
  set.seed(123)  # Seed für Reproduzierbarkeit
  probensammlung <- list()
  
  for (i in 1:num_proben) {
    stichprobenumfang <- sample(sample_sizes, 1)  # Zufälliger Stichprobenumfang aus den angegebenen Größen
    probe <- sample(data, stichprobenumfang, replace = TRUE)
    probensammlung[[i]] <- probe
  }
  
  return(probensammlung)
}

# Proben entnehmen
proben <- entnehme_proben(zeitdauer)

# Ausgabe der ersten Probe
print(proben[[1]])
```
Aufgabe 3 b)
```{r}
library(readxl)
library(ggplot2)

# Mit neuer Umgebung
load("zeitdauerGesamtheit.RData", envir = values <- new.env())

zeitdauer <- values$zeitdauerGesamtheit

zeitdauer <- na.omit(zeitdauer)
zeitdauer <- as.numeric(unlist(zeitdauer))

entnehme_proben <- function(data, num_proben = 100, sample_sizes = c(10, 50, 100, 500, 1000)) {
  set.seed(123)
  probensammlung <- list()
  
  for (i in 1:num_proben) {
    stichprobenumfang <- sample(sample_sizes, 1)
    probe <- sample(data, stichprobenumfang, replace = TRUE)
    probensammlung[[i]] <- probe
  }
  
  return(probensammlung)
}

proben <- entnehme_proben(zeitdauer)

# Funktion auf mehrere Elemente anwenden und es berechnet arithmetrisches Mittel jeder Probe
mittelwerte <- sapply(proben, mean)

# Berechnung der Varianz der Mittelwerte
var_mittelwerte <- var(mittelwerte)

# Berechnung der Grenzen für die Normalverteilung
min_wert <- min(mittelwerte) - 3 * sqrt(var_mittelwerte)
max_wert <- max(mittelwerte) + 3 * sqrt(var_mittelwerte)
x <- seq(min_wert, max_wert, length.out = 100)

# Dichte der Normalverteilung
y <- dnorm(x, mean = mean(mittelwerte), sd = sqrt(var_mittelwerte))

# Histogramm der Mittelwerte mit Normalverteilung
hist(mittelwerte, probability = TRUE, col = "lightblue", border = "black", 
     main = "Histogramm der Mittelwerte der Stichproben",
     xlab = "Mittelwerte", ylab = "Dichte")
lines(x, y, col = "red", lwd = 2)

```
Aufgabe 3 c)
```{r}
library(readxl)
library(ggplot2)

load("zeitdauerGesamtheit.RData", envir = values <- new.env())
zeitdauer <- values$zeitdauerGesamtheit

zeitdauer <- na.omit(zeitdauer)
zeitdauer <- as.numeric(unlist(zeitdauer))

entnehme_proben <- function(data, num_proben = 100, sample_sizes = c(10, 50, 100, 500, 1000)) {
  set.seed(123)
  probensammlung <- list()
  
  for (size in sample_sizes) {
    proben <- replicate(num_proben, sample(data, size, replace = TRUE), simplify = FALSE)
    probensammlung[[as.character(size)]] <- proben
  }
  
  return(probensammlung)
}

proben <- entnehme_proben(zeitdauer)

# Funktion zum Erstellen von Q-Q-Plots für jede Stichprobengröße
plot_qq_plots <- function(proben_list) {
  par(mfrow = c(2, 3))  # Layout fuer zwei zeilen plots und 3 spalten
  
  for (size in names(proben_list)) {
    mittelwerte <- sapply(proben_list[[size]], mean)
    
    qqnorm(mittelwerte, main = paste("Q-Q-Plot der Mittelwerte\nStichprobenumfang:", size),
           xlab = "Theoretische Quantile", ylab = "Empirische Quantile")
    qqline(mittelwerte, col = "red")
  }
  
  par(mfrow = c(1, 1))  # Layour zuruuecksetyen
}

plot_qq_plots(proben)

```
IM Q-Q-Plot ist die Normalverteilungslinie die Diagonale. Wenn die Werte nahe an der Diagonale sind, ist das ein Zeichen, dass sie normalverteilt sind

Aufgabe 3 d)
Der Stichprobenmittelwert ist naherungsweise normalverteilt. Je mehr Werte desto kleiner werden die Intervalle der Balken und desto naeher gleicht sich das Histogram an die Normalverteilungskurve an.